<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts36569819.25</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>adsafe.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value>
              <persistent> <string encoding="base64">AAAAAAAAAAI=</string> </persistent>
            </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>66827</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string>adsafe.js</string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
  <record id="2" aka="AAAAAAAAAAI=">
    <pickle>
      <global name="Pdata" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

// adsafe.js\n
// 2012-02-23\n
\n
//    Public Domain.\n
\n
//    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n
//    SUBJECT TO CHANGE WITHOUT NOTICE.\n
\n
//    Original url: http://www.ADsafe.org/adsafe.js\n
\n
// This file implements the core ADSAFE runtime. A site may add additional\n
// methods understanding that those methods will be made available to guest\n
// code.\n
\n
// This code should be minified before deployment.\n
// See http://javascript.crockford.com/jsmin.html\n
\n
// USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO\n
// NOT CONTROL.\n
\n
/*global window*/\n
\n
/*jslint browser: true, devel: true, nomen: true */\n
\n
/*properties "", "#", "&", "*", "+", ".", "\\/", ":blur", ":checked",\n
    ":disabled", ":enabled", ":even", ":focus", ":hidden", ":odd", ":tag",\n
    ":text", ":trim", ":unchecked", ":visible", ">", "[", "[!=", "[$=",\n
    "[*=", "[=", "[^=", "[|=", "[~=", _, "___ on ___", "___adsafe root___",\n
    ___nodes___, ___star___, __defineGetter__, "_adsafe mark_", _intercept,\n
    a, abbr, acronym, addEventListener, address, altKey, append,\n
    appendChild, apply, area, arguments, autocomplete, b, bdo, big,\n
    blockquote, blur, br, bubble, button, call, callee, caller,\n
    cancelBubble, canvas, caption, center, change, charAt, charCode, check,\n
    checked, childNodes, cite, class, className, clientX, clientY, clone,\n
    cloneNode, code, col, colgroup, combine, concat, console, constructor,\n
    count, create, createDocumentFragment, createElement, createRange,\n
    createTextNode, createTextRange, cssFloat, ctrlKey, currentStyle, dd,\n
    defaultView, del, dfn, dir, disabled, div, dl, dt, each, em, empty,\n
    enable, ephemeral, eval, exec, expand, explode, fieldset, fire,\n
    firstChild, focus, font, form, fragment, fromCharCode, get, getCheck,\n
    getChecks, getClass, getClasses, getComputedStyle, getElementById,\n
    getElementsByTagName, getMark, getMarks, getName, getNames,\n
    getOffsetHeight, getOffsetHeights, getOffsetWidth, getOffsetWidths,\n
    getParent, getSelection, getStyle, getStyles, getTagName, getTagNames,\n
    getTitle, getTitles, getValue, getValues, go, h1, h2, h3, h4, h5, h6,\n
    has, hasOwnProperty, hr, i, id, img, inRange, indexOf, input, ins,\n
    insertBefore, isArray, kbd, key, keyCode, klass, label, later, legend,\n
    length, li, lib, log, map, mark, menu, message, name, nextSibling,\n
    nodeName, nodeValue, object, off, offsetHeight, offsetWidth, ol, on,\n
    onclick, ondblclick, onfocusin, onfocusout, onkeypress, onmousedown,\n
    onmousemove, onmouseout, onmouseover, onmouseup, op, optgroup, option,\n
    p, parent, parentNode, postError, pre, prepend, preventDefault, protect,\n
    prototype, push, q, remove, removeChild, removeElement, replace,\n
    replaceChild, returnValue, row, samp, select, selection, selectionEnd,\n
    selectionStart, set, shiftKey, slice, small, span, srcElement, stack,\n
    stopPropagation, strong, style, styleFloat, sub, sup, table, tag,\n
    tagName, target, tbody, td, test, text, textarea, tfoot, th, that,\n
    thead, title, toLowerCase, toString, toUpperCase, tr, tt, type, u, ul,\n
    unwatch, value, valueOf, var, visibility, watch, window, writeln, x, y\n
*/\n
\n
var ADSAFE = (function () {\n
    "use strict";\n
\n
    var adsafe_id,      // The id of the current widget\n
        adsafe_lib,     // The script libraries loaded by the current widget\n
\n
// These member names are banned from guest scripts. The ADSAFE.get and\n
// ADSAFE.put methods will not allow access to these properties.\n
\n
        banned = {\n
            \'arguments\'     : true,\n
            callee          : true,\n
            caller          : true,\n
            constructor     : true,\n
            \'eval\'          : true,\n
            prototype       : true,\n
            stack           : true,\n
            unwatch         : true,\n
            valueOf         : true,\n
            watch           : true\n
        },\n
\n
        cache_style_object,\n
        cache_style_node,\n
        defaultView = document.defaultView,\n
        ephemeral,\n
        flipflop,       // Used in :even/:odd processing\n
        has_focus,\n
        hunter,         // Set of hunter patterns\n
        interceptors = [],\n
\n
        makeableTagName = {\n
\n
// This is the whitelist of elements that may be created with the .tag(tagName)\n
// method.\n
\n
            a         : true,\n
            abbr      : true,\n
            acronym   : true,\n
            address   : true,\n
            area      : true,\n
            b         : true,\n
            bdo       : true,\n
            big       : true,\n
            blockquote: true,\n
            br        : true,\n
            button    : true,\n
            canvas    : true,\n
            caption   : true,\n
            center    : true,\n
            cite      : true,\n
            code      : true,\n
            col       : true,\n
            colgroup  : true,\n
            dd        : true,\n
            del       : true,\n
            dfn       : true,\n
            dir       : true,\n
            div       : true,\n
            dl        : true,\n
            dt        : true,\n
            em        : true,\n
            fieldset  : true,\n
            font      : true,\n
            form      : true,\n
            h1        : true,\n
            h2        : true,\n
            h3        : true,\n
            h4        : true,\n
            h5        : true,\n
            h6        : true,\n
            hr        : true,\n
            i         : true,\n
            img       : true,\n
            input     : true,\n
            ins       : true,\n
            kbd       : true,\n
            label     : true,\n
            legend    : true,\n
            li        : true,\n
            map       : true,\n
            menu      : true,\n
            object    : true,\n
            ol        : true,\n
            optgroup  : true,\n
            option    : true,\n
            p         : true,\n
            pre       : true,\n
            q         : true,\n
            samp      : true,\n
            select    : true,\n
            small     : true,\n
            span      : true,\n
            strong    : true,\n
            sub       : true,\n
            sup       : true,\n
            table     : true,\n
            tbody     : true,\n
            td        : true,\n
            textarea  : true,\n
            tfoot     : true,\n
            th        : true,\n
            thead     : true,\n
            tr        : true,\n
            tt        : true,\n
            u         : true,\n
            ul        : true,\n
            \'var\'     : true\n
        },\n
        name,\n
        pecker,     // set of pecker patterns\n
        result,\n
        star,\n
        the_range,\n
        value;\n
\n
\n
//  The error function is called if there is a violation or confusion.\n
//  It throws an exception.\n
\n
    function error(message) {\n
        ADSAFE.log("ADsafe error: " + (message || "ADsafe violation."));\n
        throw {\n
            name: "ADsafe",\n
            message: message || "ADsafe violation."\n
        };\n
    }\n
\n
\n
//    Some of JavaScript\'s implicit string conversions can grant extraordinary\n
//    powers to untrusted code. So we use the string_check function to prevent\n
//    such abuses.\n
\n
    function string_check(string) {\n
        if (typeof string !== \'string\') {\n
            error("ADsafe string violation.");\n
        }\n
        return string;\n
    }\n
\n
\n
//    The object.hasOwnProperty method has a number of hazards. So we wrap it in\n
//    the owns function.\n
\n
    function owns(object, string) {\n
        return object && typeof object === \'object\' &&\n
            Object.prototype.hasOwnProperty.call(object, string_check(string));\n
    }\n
\n
    if (Function.__defineGetter__) {\n
\n
//  Firefox implemented some of its array methods carelessly. If a method is\n
//  called as a function it returns the global object. ADsafe cannot tolerate\n
//  that, so we must wrap the methods to make them safer and slower.\n
\n
        (function mozilla(name) {\n
            var method = Array.prototype[name];\n
            Array.prototype[name] = function () {\n
                return !this || this.window ? error() : method.apply(this, arguments);\n
            };\n
            return mozilla;\n
        }\n
        (\'concat\')\n
        (\'every\')\n
        (\'filter\')\n
        (\'forEach\')\n
        (\'map\')\n
        (\'reduce\')\n
        (\'reduceRight\')\n
        (\'reverse\')\n
        (\'slice\')\n
        (\'some\')\n
        (\'sort\'));\n
\n
//  Firefox also leaked some internal state through negative subscripts of\n
//  functions. This plugs the holes.\n
\n
        (function (p, f) {\n
            p.__defineGetter__(\'-1\', f);\n
            p.__defineGetter__(\'-3\', f);\n
            p.__defineGetter__(\'-6\', f);\n
        }(Function.prototype, function () {\n
            return null;\n
        }));\n
    }\n
\n
\n
//  The reject functions enforce the restriction on property names.\n
//  reject_property allows access only to objects and arrays. It does not allow\n
//  use of the banned names, or names that are not strings and not numbers,\n
//  or strings that start or end with _.\n
\n
    function reject_name(name) {\n
        return typeof name !== \'number\' && (typeof name !== \'string\' ||\n
            banned[name] || name.charAt(0) === \'_\' || name.slice(-1) === \'_\');\n
    }\n
\n
\n
    function reject_property(object, name) {\n
        return typeof object !== \'object\' || reject_name(name);\n
    }\n
\n
\n
    function reject_global(that) {\n
        if (that.window) {\n
            error();\n
        }\n
    }\n
\n
\n
    function getStyleObject(node) {\n
\n
// The getStyleObject function returns the computed style object for a node.\n
\n
        if (node === cache_style_node) {\n
            return cache_style_object;\n
        }\n
        cache_style_node = node;\n
        cache_style_object =\n
            node.currentStyle || defaultView.getComputedStyle(node, \'\');\n
        return cache_style_object;\n
    }\n
\n
\n
    function walkTheDOM(node, func, skip) {\n
\n
// Recursively traverse the DOM tree, starting with the node, in document\n
// source order, calling the func on each node visisted.\n
\n
        if (!skip) {\n
            func(node);\n
        }\n
        node = node.firstChild;\n
        while (node) {\n
            walkTheDOM(node, func);\n
            node = node.nextSibling;\n
        }\n
    }\n
\n
\n
    function purge_event_handlers(node) {\n
\n
// We attach all event handlers to an \'___ on ___\' property. The property name\n
// contains spaces to insure that there is no collision with HTML attribues.\n
// Keeping the handlers in a single property makes it easy to remove them\n
// all at once. Removal is required to avoid memory leakage on IE6 and IE7.\n
\n
        walkTheDOM(node, function (node) {\n
            if (node.tagName) {\n
                node[\'___ on ___\'] = node.change = null;\n
            }\n
        });\n
    }\n
\n
\n
    function parse_query(text, id) {\n
\n
// Convert a query string into an array of op/name/value selectors.\n
// A query string is a sequence of triples wrapped in brackets; or names,\n
// possibly prefixed by # . & > _, or :option, or * or /. A triple is a name,\n
// and operator (one of [=, [!=, [*=, [~=, [|=, [$=, or [^=) and a value.\n
\n
// If the id parameter is supplied, then the name following # must have the\n
// id as a prefix and must match the ADsafe rule for id: being all uppercase\n
// letters and digits with one underbar.\n
\n
// A name must be all lower case and may contain digits, -, or _.\n
\n
        var match,          // A match array\n
            query = [],     // The resulting query array\n
            selector,\n
            qx = id\n
                ? /^\\s*(?:([\\*\\/])|\\[\\s*([a-z][0-9a-z_\\-]*)\\s*(?:([!*~|$\\^]?\\=)\\s*([0-9A-Za-z_\\-*%&;.\\/:!]+)\\s*)?\\]|#\\s*([A-Z]+_[A-Z0-9]+)|:\\s*([a-z]+)|([.&_>\\+]?)\\s*([a-z][0-9a-z\\-]*))\\s*/\n
                : /^\\s*(?:([\\*\\/])|\\[\\s*([a-z][0-9a-z_\\-]*)\\s*(?:([!*~|$\\^]?\\=)\\s*([0-9A-Za-z_\\-*%&;.\\/:!]+)\\s*)?\\]|#\\s*([\\-A-Za-z0-9_]+)|:\\s*([a-z]+)|([.&_>\\+]?)\\s*([a-z][0-9a-z\\-]*))\\s*/;\n
\n
// Loop over all of the selectors in the text.\n
\n
        do {\n
\n
// The qx teases the components of one selector out of the text, ignoring\n
// whitespace.\n
\n
//          match[0]  the whole selector\n
//          match[1]  * /\n
//          match[2]  attribute name\n
//          match[3]  = != *= ~= |= $= ^=\n
//          match[4]  attribute value\n
//          match[5]  # id\n
//          match[6]  : option\n
//          match[7]  . & _ > +\n
//          match[8]      name\n
\n
            match = qx.exec(string_check(text));\n
            if (!match) {\n
                error("ADsafe: Bad query:" + text);\n
            }\n
\n
// Make a selector object and stuff it in the query.\n
\n
            if (match[1]) {\n
\n
// The selector is * or /\n
\n
                selector = {\n
                    op: match[1]\n
                };\n
            } else if (match[2]) {\n
\n
// The selector is in brackets.\n
\n
                selector = match[3] ? {\n
                    op: \'[\' + match[3],\n
                    name: match[2],\n
                    value: match[4]\n
                } : {\n
                    op: \'[\',\n
                    name: match[2]\n
                };\n
            } else if (match[5]) {\n
\n
// The selector is an id.\n
\n
                if (query.length > 0 || match[5].length <= id.length ||\n
                        match[5].slice(0, id.length) !== id) {\n
                    error("ADsafe: Bad query: " + text);\n
                }\n
                selector = {\n
                    op: \'#\',\n
                    name: match[5]\n
                };\n
\n
// The selector is a colon.\n
\n
            } else if (match[6]) {\n
                selector = {\n
                    op: \':\' + match[6]\n
                };\n
\n
// The selector is one of > + . & _ or a naked tag name\n
\n
            } else {\n
                selector = {\n
                    op: match[7],\n
                    name: match[8]\n
                };\n
            }\n
\n
// Add the selector to the query.\n
\n
            query.push(selector);\n
\n
// Remove the selector from the text. If there is more text, have another go.\n
\n
            text = text.slice(match[0].length);\n
        } while (text);\n
        return query;\n
    }\n
\n
\n
    hunter = {\n
\n
// These functions implement the hunter behaviors.\n
\n
        \'\': function (node) {\n
            var array, nodelist = node.getElementsByTagName(name), i, length;\n
\n
// getElementsByTagName produces a nodeList, which is one of the world\'s most\n
// inefficient data structures. It is so slow that JavaScript\'s pseudo arrays\n
// look terrifically swift by comparison. So we do the conversion. This is\n
// easily done on some browsers, less easily on others.\n
\n
            try {\n
                array = Array.prototype.slice.call(nodelist, 0);\n
                result = result.length ? result.concat(array) : array;\n
            } catch (ie) {\n
                length = nodelist.length;\n
                for (i = 0; i < length; i += 1) {\n
                    result.push(nodelist[i]);\n
                }\n
            }\n
        },\n
        \'+\': function (node) {\n
            node = node.nextSibling;\n
            name = name.toUpperCase();\n
            while (node && !node.tagName) {\n
                node = node.nextSibling;\n
            }\n
            if (node && node.tagName === name) {\n
                result.push(node);\n
            }\n
        },\n
        \'>\': function (node) {\n
            node = node.firstChild;\n
            name = name.toUpperCase();\n
            while (node) {\n
                if (node.tagName === name) {\n
                    result.push(node);\n
                }\n
                node = node.nextSibling;\n
            }\n
        },\n
        \'#\': function () {\n
            var n = document.getElementById(name);\n
            if (n.tagName) {\n
                result.push(n);\n
            }\n
        },\n
        \'/\': function (node) {\n
            var nodes = node.childNodes, i, length = nodes.length;\n
            for (i = 0; i < length; i += 1) {\n
                result.push(nodes[i]);\n
            }\n
        },\n
        \'*\': function (node) {\n
            star = true;\n
            walkTheDOM(node, function (node) {\n
                result.push(node);\n
            }, true);\n
        }\n
    };\n
\n
    pecker = {\n
        \'.\': function (node) {\n
            return (\' \' + node.className + \' \').indexOf(\' \' + name + \' \') >= 0;\n
        },\n
        \'&\': function (node) {\n
            return node.name === name;\n
        },\n
        \'_\': function (node) {\n
            return node.type === name;\n
        },\n
        \'[\': function (node) {\n
            return typeof node[name] === \'string\';\n
        },\n
        \'[=\': function (node) {\n
            var member = node[name];\n
            return typeof member === \'string\' && member === value;\n
        },\n
        \'[!=\': function (node) {\n
            var member = node[name];\n
            return typeof member === \'string\' && member !== value;\n
        },\n
        \'[^=\': function (node) {\n
            var member = node[name];\n
            return typeof member === \'string\' &&\n
                member.slice(0, member.length) === value;\n
        },\n
        \'[$=\': function (node) {\n
            var member = node[name];\n
            return typeof member === \'string\' &&\n
                member.slice(-member.length) === value;\n
        },\n
        \'[*=\': function (node) {\n
            var member = node[name];\n
            return typeof member === \'string\' &&\n
                member.indexOf(value) >= 0;\n
        },\n
        \'[~=\': function (node) {\n
            var member = node[name];\n
            return typeof member === \'string\' &&\n
                (\' \' + member + \' \').indexOf(\' \' + value + \' \') >= 0;\n
        },\n
        \'[|=\': function (node) {\n
            var member = node[name];\n
            return typeof member === \'string\' &&\n
                (\'-\' + member + \'-\').indexOf(\'-\' + value + \'-\') >= 0;\n
        },\n
        \':blur\': function (node) {\n
            return node !== has_focus;\n
        },\n
        \':checked\': function (node) {\n
            return node.checked;\n
        },\n
        \':disabled\': function (node) {\n
            return node.tagName && node.disabled;\n
        },\n
        \':enabled\': function (node) {\n
            return node.tagName && !node.disabled;\n
        },\n
        \':even\': function (node) {\n
            var f;\n
            if (node.tagName) {\n
                f = flipflop;\n
                flipflop = !flipflop;\n
                return f;\n
            }\n
            return false;\n
        },\n
        \':focus\': function (node) {\n
            return node === has_focus;\n
        },\n
        \':hidden\': function (node) {\n
            return node.tagName && getStyleObject(node).visibility !== \'visible\';\n
        },\n
        \':odd\': function (node) {\n
            if (node.tagName) {\n
                flipflop = !flipflop;\n
                return flipflop;\n
            }\n
            return false;\n
        },\n
        \':tag\': function (node) {\n
            return node.tagName;\n
        },\n
        \':text\': function (node) {\n
            return node.nodeName === \'#text\';\n
        },\n
        \':trim\': function (node) {\n
            return node.nodeName !== \'#text\' || /\\W/.test(node.nodeValue);\n
        },\n
        \':unchecked\': function (node) {\n
            return node.tagName && !node.checked;\n
        },\n
        \':visible\': function (node) {\n
            return node.tagName && getStyleObject(node).visibility === \'visible\';\n
        }\n
    };\n
\n
\n
    function quest(query, nodes) {\n
        var selector, func, i, j;\n
\n
// Step through each selector.\n
\n
        for (i = 0; i < query.length; i += 1) {\n
            selector = query[i];\n
            name = selector.name;\n
            func = hunter[selector.op];\n
\n
// There are two kinds of selectors: hunters and peckers. If this is a hunter,\n
// loop through the the nodes, passing each node to the hunter function.\n
// Accumulate all the nodes it finds.\n
\n
            if (typeof func === \'function\') {\n
                if (star) {\n
                    error("ADsafe: Query violation: *" + selector.op +\n
                        (selector.name || \'\'));\n
                }\n
                result = [];\n
                for (j = 0; j < nodes.length; j += 1) {\n
                    func(nodes[j]);\n
                }\n
            } else {\n
\n
// If this is a pecker, get its function. There is a special case for\n
// the :first and :rest selectors because they are so simple.\n
\n
                value = selector.value;\n
                flipflop = false;\n
                func = pecker[selector.op];\n
                if (typeof func !== \'function\') {\n
                    switch (selector.op) {\n
                    case \':first\':\n
                        result = nodes.slice(0, 1);\n
                        break;\n
                    case \':rest\':\n
                        result = nodes.slice(1);\n
                        break;\n
                    default:\n
                        error(\'ADsafe: Query violation: :\' + selector.op);\n
                    }\n
                } else {\n
\n
// For the other selectors, make an array of nodes that are filtered by\n
// the pecker function.\n
\n
                    result = [];\n
                    for (j = 0; j < nodes.length; j += 1) {\n
                        if (func(nodes[j])) {\n
                            result.push(nodes[j]);\n
                        }\n
                    }\n
                }\n
            }\n
            nodes = result;\n
        }\n
        return result;\n
    }\n
\n
\n
    function make_root(root, id) {\n
\n
        if (id) {\n
            if (root.tagName !== \'DIV\') {\n
                error(\'ADsafe: Bad node.\');\n
            }\n
        } else {\n
            if (root.tagName !== \'BODY\') {\n
                error(\'ADsafe: Bad node.\');\n
            }\n
        }\n
\n
// A Bunch is a container that holds zero or more dom nodes.\n
// It has many useful methods.\n
\n
        function Bunch(nodes) {\n
            this.___nodes___ = nodes;\n
            this.___star___ = star && nodes.length > 1;\n
            star = false;\n
        }\n
\n
        var allow_focus = true,\n
            dom,\n
            dom_event = function (e) {\n
                var key,\n
                    target,\n
                    that,\n
                    the_event,\n
                    the_target,\n
                    the_actual_event = e || event,\n
                    type = the_actual_event.type;\n
\n
// Get the target node and wrap it in a bunch.\n
\n
                the_target = the_actual_event.target || the_actual_event.srcElement;\n
                target = new Bunch([the_target]);\n
                that = target;\n
\n
// Use the PPK hack to make focus bubbly on IE.\n
// When a widget has focus, it can use the focus method.\n
\n
                switch (type) {\n
                case \'mousedown\':\n
                    allow_focus = true;\n
                    if (document.selection) {\n
                        the_range = document.selection.createRange();\n
                    }\n
                    break;\n
                case \'focus\':\n
                case \'focusin\':\n
                    allow_focus = true;\n
                    has_focus = the_target;\n
                    the_actual_event.cancelBubble = false;\n
                    type = \'focus\';\n
                    break;\n
                case \'blur\':\n
                case \'focusout\':\n
                    allow_focus = false;\n
                    has_focus = null;\n
                    type = \'blur\';\n
                    break;\n
                case \'keypress\':\n
                    allow_focus = true;\n
                    has_focus = the_target;\n
                    key = String.fromCharCode(the_actual_event.charCode ||\n
                        the_actual_event.keyCode);\n
                    switch (key) {\n
                    case \'\\u000d\':\n
                    case \'\\u000a\':\n
                        type = \'enterkey\';\n
                        break;\n
                    case \'\\u001b\':\n
                        type = \'escapekey\';\n
                        break;\n
                    }\n
                    break;\n
\n
// This is a workaround for Safari.\n
\n
                case \'click\':\n
                    allow_focus = true;\n
                    break;\n
                }\n
                if (the_actual_event.cancelBubble &&\n
                        the_actual_event.stopPropagation) {\n
                    the_actual_event.stopPropagation();\n
                }\n
\n
// Make the event object.\n
\n
                the_event = {\n
                    altKey: the_actual_event.altKey,\n
                    ctrlKey: the_actual_event.ctrlKey,\n
                    bubble: function () {\n
\n
// Bubble up. Get the parent of that node. It becomes the new that.\n
// getParent throws when bubbling is not possible.\n
\n
                        try {\n
                            var parent = that.getParent(),\n
                                b = parent.___nodes___[0];\n
                            that = parent;\n
                            the_event.that = that;\n
\n
// If that node has an event handler, fire it. Otherwise, bubble up.\n
\n
                            if (b[\'___ on ___\'] &&\n
                                    b[\'___ on ___\'][type]) {\n
                                that.fire(the_event);\n
                            } else {\n
                                the_event.bubble();\n
                            }\n
                        } catch (e) {\n
                            error(e);\n
                        }\n
                    },\n
                    key: key,\n
                    preventDefault: function () {\n
                        if (the_actual_event.preventDefault) {\n
                            the_actual_event.preventDefault();\n
                        }\n
                        the_actual_event.returnValue = false;\n
                    },\n
                    shiftKey: the_actual_event.shiftKey,\n
                    target: target,\n
                    that: that,\n
                    type: type,\n
                    x: the_actual_event.clientX,\n
                    y: the_actual_event.clientY\n
                };\n
\n
// If the target has event handlers, then fire them. Otherwise, bubble up.\n
\n
                if (the_target[\'___ on ___\'] &&\n
                        the_target[\'___ on ___\'][the_event.type]) {\n
                    target.fire(the_event);\n
                } else {\n
                    for (;;) {\n
                        the_target = the_target.parentNode;\n
                        if (!the_target) {\n
                            break;\n
                        }\n
                        if (the_target[\'___ on ___\'] &&\n
                                the_target[\'___ on ___\'][the_event.type]) {\n
                            that = new Bunch([the_target]);\n
                            the_event.that = that;\n
                            that.fire(the_event);\n
                            break;\n
                        }\n
                        if (the_target[\'___adsafe root___\']) {\n
                            break;\n
                        }\n
                    }\n
                }\n
                if (the_event.type === \'escapekey\') {\n
                    if (ephemeral) {\n
                        ephemeral.remove();\n
                    }\n
                    ephemeral = null;\n
                }\n
                that = the_target = the_event = the_actual_event = null;\n
                return;\n
            };\n
\n
// Mark the node as a root. This prevents event bubbling from propagating\n
// past it.\n
\n
        root[\'___adsafe root___\'] = \'___adsafe root___\';\n
\n
        Bunch.prototype = {\n
            append: function (appendage) {\n
                reject_global(this);\n
                var b = this.___nodes___,\n
                    flag = false,\n
                    i,\n
                    j,\n
                    node,\n
                    rep;\n
                if (b.length === 0 || !appendage) {\n
                    return this;\n
                }\n
                if (appendage instanceof Array) {\n
                    if (appendage.length !== b.length) {\n
                        error(\'ADsafe: Array length: \' + b.length + \'-\' +\n
                            value.length);\n
                    }\n
                    for (i = 0; i < b.length; i += 1) {\n
                        rep = appendage[i].___nodes___;\n
                        for (j = 0; j < rep.length; j += 1) {\n
                            b[i].appendChild(rep[j]);\n
                        }\n
                    }\n
                } else {\n
                    rep = appendage.___nodes___;\n
                    for (i = 0; i < b.length; i += 1) {\n
                        node = b[i];\n
                        for (j = 0; j < rep.length; j += 1) {\n
                            node.appendChild(flag\n
                                    ? rep[j].cloneNode(true)\n
                                    : rep[j]);\n
                        }\n
                        flag = true;\n
                    }\n
                }\n
                return this;\n
            },\n
            blur: function () {\n
                reject_global(this);\n
                var b = this.___nodes___, i, node;\n
                has_focus = null;\n
                for (i = 0; i < b.length; i += 1) {\n
                    node = b[i];\n
                    if (node.blur) {\n
                        node.blur();\n
                    }\n
                }\n
                return this;\n
            },\n
            check: function (value) {\n
                reject_global(this);\n
                var b = this.___nodes___, i, node;\n
                if (value instanceof Array) {\n
                    if (value.length !== b.length) {\n
                        error(\'ADsafe: Array length: \' + b.length + \'-\' +\n
                            value.length);\n
                    }\n
                    for (i = 0; i < b.length; i += 1) {\n
                        node = b[i];\n
                        if (node.tagName) {\n
                            node.checked = !!value[i];\n
                        }\n
                    }\n
                } else {\n
                    for (i = 0; i < b.length; i += 1) {\n
                        node = b[i];\n
                        if (node.tagName) {\n
                            node.checked = !!value;\n
                        }\n
                    }\n
                }\n
                return this;\n
            },\n
            \'class\': function (value) {\n
                reject_global(this);\n
                var b = this.___nodes___, i, node;\n
                if (value instanceof Array) {\n
                    if (value.length !== b.length) {\n
                        error(\'ADsafe: Array length: \' + b.length + \'-\' +\n
                            value.length);\n
                    }\n
                    for (i = 0; i < b.length; i += 1) {\n
                        if (/url/i.test(string_check(value[i]))) {\n
                            error(\'ADsafe error.\');\n
                        }\n
                        node = b[i];\n
                        if (node.tagName) {\n
                            node.className = value[i];\n
                        }\n
                    }\n
                } else {\n
                    if (/url/i.test(string_check(value))) {\n
                        error(\'ADsafe error.\');\n
                    }\n
                    for (i = 0; i < b.length; i += 1) {\n
                        node = b[i];\n
                        if (node.tagName) {\n
                            node.className = value;\n
                        }\n
                    }\n
                }\n
                return this;\n
            },\n
            clone: function (deep, n) {\n
                var a = [],\n
                    b = this.___nodes___,\n
                    c,\n
                    i,\n
                    j,\n
                    k = n || 1;\n
                for (i = 0; i < k; i += 1) {\n
                    c = [];\n
                    for (j = 0; j < b.length; j += 1) {\n
                        c.push(b[j].cloneNode(deep));\n
                    }\n
                    a.push(new Bunch(c));\n
                }\n
                return n ? a : a[0];\n
            },\n
            count: function () {\n
                reject_global(this);\n
                return this.___nodes___.length;\n
            },\n
            each: function (func) {\n
                reject_global(this);\n
                var b = this.___nodes___, i;\n
                if (typeof func === \'function\') {\n
                    for (i = 0; i < b.length; i += 1) {\n
                        func(new Bunch([b[i]]));\n
                    }\n
                    return this;\n
                }\n
                error();\n
            },\n
            empty: function () {\n
                reject_global(this);\n
                var b = this.___nodes___, i, node;\n
                if (value instanceof Array) {\n
                    if (value.length !== b.length) {\n
                        error(\'ADsafe: Array length: \' + b.length + \'-\' +\n
                            value.length);\n
                    }\n
                    for (i = 0; i < b.length; i += 1) {\n
                        node = b[i];\n
                        while (node.firstChild) {\n
                            purge_event_handlers(node);\n
                            node.removeChild(node.firstChild);\n
                        }\n
                    }\n
                } else {\n
                    for (i = 0; i < b.length; i += 1) {\n
                        node = b[i];\n
                        while (node.firstChild) {\n
                            purge_event_handlers(node);\n
                            node.removeChild(node.firstChild);\n
                        }\n
                    }\n
                }\n
                return this;\n
            },\n
            enable: function (enable) {\n
                reject_global(this);\n
                var b = this.___nodes___, i, node;\n
                if (enable instanceof Array) {\n
                    if (enable.length !== b.length) {\n
                        error(\'ADsafe: Array length: \' + b.length + \'-\' +\n
                            enable.length);\n
                    }\n
                    for (i = 0; i < b.length; i += 1) {\n
                        node = b[i];\n
                        if (node.tagName) {\n
                            node.disabled = !enable[i];\n
                        }\n
                    }\n
                } else {\n
                    for (i = 0; i < b.length; i += 1) {\n
                        node = b[i];\n
                        if (node.tagName) {\n
                            node.disabled = !enable;\n
                        }\n
                    }\n
                }\n
                return this;\n
            },\n
            ephemeral: function () {\n
                reject_global(this);\n
                if (ephemeral) {\n
                    ephemeral.remove();\n
                }\n
                ephemeral = this;\n
                return this;\n
            },\n
            explode: function () {\n
                reject_global(this);\n
                var a = [], b = this.___nodes___, i;\n
                for (i = 0; i < b.length; i += 1) {\n
                    a[i] = new Bunch([b[i]]);\n
                }\n
                return a;\n
            },\n
            fire: function (event) {\n
\n
    // Fire an event on an object. The event can be either\n
    // a string containing the name of the event, or an\n
    // object containing a type property containing the\n
    // name of the event. Handlers registered by the \'on\'\n
    // method that match the event name will be invoked.\n
\n
                reject_global(this);\n
                var array,\n
                    b,\n
                    i,\n
                    j,\n
                    n,\n
                    node,\n
                    on,\n
                    type;\n
\n
                if (typeof event === \'string\') {\n
                    type = event;\n
                    event = {type: type};\n
                } else if (typeof event === \'object\') {\n
                    type = event.type;\n
                } else {\n
                    error();\n
                }\n
                b = this.___nodes___;\n
                n = b.length;\n
                for (i = 0; i < n; i += 1) {\n
                    node = b[i];\n
                    on = node[\'___ on ___\'];\n
\n
    // If an array of handlers exist for this event, then\n
    // loop through it and execute the handlers in order.\n
\n
                    if (owns(on, type)) {\n
                        array = on[type];\n
                        for (j = 0; j < array.length; j += 1) {\n
\n
    // Invoke a handler. Pass the event object.\n
\n
                            array[j].call(this, event);\n
                        }\n
                    }\n
                }\n
                return this;\n
            },\n
            focus: function () {\n
                reject_global(this);\n
                var b = this.___nodes___;\n
                if (b.length > 0 && allow_focus) {\n
                    has_focus = b[0].focus();\n
                    return this;\n
                }\n
                error();\n
            },\n
            fragment: function () {\n
                reject_global(this);\n
                return new Bunch([document.createDocumentFragment()]);\n
            },\n
            getCheck: function () {\n
                return this.getChecks()[0];\n
            },\n
            getChecks: function () {\n
                reject_global(this);\n
                var a = [], b = this.___nodes___, i;\n
                for (i = 0; i < b.length; i += 1) {\n
                    a[i] = b[i].checked;\n
                }\n
                return a;\n
            },\n
            getClass: function () {\n
                return this.getClasses()[0];\n
            },\n
            getClasses: function () {\n
                reject_global(this);\n
                var a = [], b = this.___nodes___, i;\n
                for (i = 0; i < b.length; i += 1) {\n
                    a[i] = b[i].className;\n
                }\n
                return a;\n
            },\n
            getMark: function () {\n
                return this.getMarks()[0];\n
            },\n
            getMarks: function () {\n
                reject_global(this);\n
                var a = [], b = this.___nodes___, i;\n
                for (i = 0; i < b.length; i += 1) {\n
                    a[i] = b[i][\'_adsafe mark_\'];\n
                }\n
                return a;\n
            },\n
            getName: function () {\n
                return this.getNames()[0];\n
            },\n
            getNames: function () {\n
                reject_global(this);\n
                var a = [], b = this.___nodes___, i;\n
                for (i = 0; i < b.length; i += 1) {\n
                    a[i] = b[i].name;\n
                }\n
                return a;\n
            },\n
            getOffsetHeight: function () {\n
                return this.getOffsetHeights()[0];\n
            },\n
            getOffsetHeights: function () {\n
                reject_global(this);\n
                var a = [], b = this.___nodes___, i;\n
                for (i = 0; i < b.length; i += 1) {\n
                    a[i] = b[i].offsetHeight;\n
                }\n
                return a;\n
            },\n
            getOffsetWidth: function () {\n
                return this.getOffsetWidths()[0];\n
            },\n
            getOffsetWidths: function () {\n
                reject_global(this);\n
                var a = [], b = this.___nodes___, i;\n
                for (i = 0; i < b.length; i += 1) {\n
                    a[i] = b[i].offsetWidth;\n
                }\n
                return a;\n
            },\n
            getParent: function () {\n
                reject_global(this);\n
                var a = [], b = this.___nodes___, i, n;\n
                for (i = 0; i < b.length; i += 1) {\n
                    n = b[i].parentNode;\n
                    if (n[\'___adsafe root___\']) {\n
                        error(\'ADsafe parent violation.\');\n
                    }\n
                    a[i] = n;\n
                }\n
                return new Bunch(a);\n
            },\n
            getSelection: function () {\n
                reject_global(this);\n
                var b = this.___nodes___, end, node, start, range;\n
                if (b.length === 1 && allow_focus) {\n
                    node = b[0];\n
                    if (typeof node.selectionStart === \'number\') {\n
                        start = node.selectionStart;\n
                        end = node.selectionEnd;\n
                        return node.value.slice(start, end);\n
                    }\n
                    range = node.createTextRange();\n
                    range.expand(\'textedit\');\n
                    if (range.inRange(the_range)) {\n
                        return the_range.text;\n
                    }\n
                }\n
                return null;\n
            },\n
            getStyle: function (name) {\n
                return this.getStyles(name)[0];\n
            },\n
            getStyles: function (name) {\n
                reject_global(this);\n
                if (reject_name(name)) {\n
                    error("ADsafe style violation.");\n
                }\n
                var a = [], b = this.___nodes___, i, node, s;\n
                for (i = 0; i < b.length; i += 1) {\n
                    node = b[i];\n
                    if (node.tagName) {\n
                        s = name !== \'float\'\n
                            ? getStyleObject(node)[name]\n
                            : getStyleObject(node).cssFloat ||\n
                                getStyleObject(node).styleFloat;\n
                        if (typeof s === \'string\') {\n
                            a[i] = s;\n
                        }\n
                    }\n
                }\n
                return a;\n
            },\n
            getTagName: function () {\n
                return this.getTagNames()[0];\n
            },\n
            getTagNames: function () {\n
                reject_global(this);\n
                var a = [], b = this.___nodes___, i, name;\n
                for (i = 0; i < b.length; i += 1) {\n
                    name = b[i].tagName;\n
                    a[i] = typeof name === \'string\' ? name.toLowerCase() : name;\n
                }\n
                return a;\n
            },\n
            getTitle: function () {\n
                return this.getTitles()[0];\n
            },\n
            getTitles: function () {\n
                reject_global(this);\n
                var a = [], b = this.___nodes___, i;\n
                for (i = 0; i < b.length; i += 1) {\n
                    a[i] = b[i].title;\n
                }\n
                return a;\n
            },\n
            getValue: function () {\n
                return this.getValues()[0];\n
            },\n
            getValues: function () {\n
                reject_global(this);\n
                var a = [], b = this.___nodes___, i, node;\n
                for (i = 0; i < b.length; i += 1) {\n
                    node = b[i];\n
                    if (node.nodeName === \'#text\') {\n
                        a[i] = node.nodeValue;\n
                    } else if (node.tagName && node.type !== \'password\') {\n
                        a[i] = node.value;\n
                        if (a[i] === undefined && node.firstChild &&\n
                                node.firstChild.nodeName === \'#text\') {\n
                            a[i] = node.firstChild.nodeValue;\n
                        }\n
                    }\n
                }\n
                return a;\n
            },\n
            klass: function (value) {\n
                return this[\'class\'](value);\n
            },\n
            mark: function (value) {\n
                reject_global(this);\n
                var b = this.___nodes___, i, node;\n
                if (value instanceof Array) {\n
                    if (value.length !== b.length) {\n
                        error(\'ADsafe: Array length: \' + b.length + \'-\' +\n
                            value.length);\n
                    }\n
                    for (i = 0; i < b.length; i += 1) {\n
                        node = b[i];\n
                        if (node.tagName) {\n
                            node[\'_adsafe mark_\'] = String(value[i]);\n
                        }\n
                    }\n
                } else {\n
                    for (i = 0; i < b.length; i += 1) {\n
                        node = b[i];\n
                        if (node.tagName) {\n
                            node[\'_adsafe mark_\'] = String(value);\n
                        }\n
                    }\n
                }\n
                return this;\n
            },\n
            off: function (type) {\n
                reject_global(this);\n
                var b = this.___nodes___, i, node;\n
                for (i = 0; i < b.length; i += 1) {\n
                    node = b[i];\n
                    if (typeof type === \'string\') {\n
                        if (typeof node[\'___ on ___\']) {\n
                            node[\'___ on ___\'][type] = null;\n
                        }\n
                    } else {\n
                        node[\'___ on ___\'] = null;\n
                    }\n
                }\n
                return this;\n
            },\n
            on: function (type, func) {\n
                reject_global(this);\n
                if (typeof type !== \'string\' || typeof func !== \'function\') {\n
                    error();\n
                }\n
\n
                var b = this.___nodes___, i, node, on, ontype;\n
                for (i = 0; i < b.length; i += 1) {\n
                    node = b[i];\n
\n
// The change event does not propogate, so we must put the handler on the\n
// instance.\n
\n
                    if (type === \'change\') {\n
                        ontype = \'on\' + type;\n
                        if (node[ontype] !== dom_event) {\n
                            node[ontype] = dom_event;\n
                        }\n
                    }\n
\n
// Register an event. Put the function in a handler array, making one if it\n
// doesn\'t yet exist for this type on this node.\n
\n
                    on = node[\'___ on ___\'];\n
                    if (!on) {\n
                        on = {};\n
                        node[\'___ on ___\'] = on;\n
                    }\n
                    if (owns(on, type)) {\n
                        on[type].push(func);\n
                    } else {\n
                        on[type] = [func];\n
                    }\n
                }\n
                return this;\n
            },\n
            protect: function () {\n
                reject_global(this);\n
                var b = this.___nodes___, i;\n
                for (i = 0; i < b.length; i += 1) {\n
                    b[i][\'___adsafe root___\'] = \'___adsafe root___\';\n
                }\n
                return this;\n
            },\n
            q: function (text) {\n
                reject_global(this);\n
                star = this.___star___;\n
                return new Bunch(quest(parse_query(string_check(text), id),\n
                    this.___nodes___));\n
            },\n
            remove: function () {\n
                reject_global(this);\n
                this.replace();\n
            },\n
            replace: function (replacement) {\n
                reject_global(this);\n
                var b = this.___nodes___,\n
                    flag = false,\n
                    i,\n
                    j,\n
                    newnode,\n
                    node,\n
                    parent,\n
                    rep;\n
                if (b.length === 0) {\n
                    return;\n
                }\n
                for (i = 0; i < b.length; i += 1) {\n
                    purge_event_handlers(b[i]);\n
                }\n
                if (!replacement || replacement.length === 0 ||\n
                        (replacement.___nodes___ &&\n
                        replacement.___nodes___.length === 0)) {\n
                    for (i = 0; i < b.length; i += 1) {\n
                        node = b[i];\n
                        purge_event_handlers(node);\n
                        if (node.parentNode) {\n
                            node.parentNode.removeChild(node);\n
                        }\n
                    }\n
                } else if (replacement instanceof Array) {\n
                    if (replacement.length !== b.length) {\n
                        error(\'ADsafe: Array length: \' +\n
                            b.length + \'-\' + value.length);\n
                    }\n
                    for (i = 0; i < b.length; i += 1) {\n
                        node = b[i];\n
                        parent = node.parentNode;\n
                        purge_event_handlers(node);\n
                        if (parent) {\n
                            rep = replacement[i].___nodes___;\n
                            if (rep.length > 0) {\n
                                newnode = rep[0];\n
                                parent.replaceChild(newnode, node);\n
                                for (j = 1; j < rep.length; j += 1) {\n
                                    node = newnode;\n
                                    newnode = rep[j];\n
                                    parent.insertBefore(newnode, node.nextSibling);\n
                                }\n
                            } else {\n
                                parent.removeChild(node);\n
                            }\n
                        }\n
                    }\n
                } else {\n
                    rep = replacement.___nodes___;\n
                    for (i = 0; i < b.length; i += 1) {\n
                        node = b[i];\n
                        purge_event_handlers(node);\n
                        parent = node.parentNode;\n
                        if (parent) {\n
                            newnode = flag ? rep[0].cloneNode(true) : rep[0];\n
                            parent.replaceChild(newnode, node);\n
                            for (j = 1; j < rep.length; j += 1) {\n
                                node = newnode;\n
                                newnode = flag ? rep[j].clone(true) : rep[j];\n
                                parent.insertBefore(newnode, node.nextSibling);\n
                            }\n
                            flag = true;\n
                        }\n
                    }\n
                }\n
                return this;\n
            },\n
            select: function () {\n
                reject_global(this);\n
                var b = this.___nodes___;\n
                if (b.length < 1 || !allow_focus) {\n
                    error();\n
                }\n
                b[0].focus();\n
                b[0].select();\n
                return this;\n
            },\n
            selection: function (string) {\n
                reject_global(this);\n
                string_check(string);\n
                var b = this.___nodes___, end, node, old, start, range;\n
                if (b.length === 1 && allow_focus) {\n
                    node = b[0];\n
                    if (typeof node.selectionStart === \'number\') {\n
                        start = node.selectionStart;\n
                        end = node.selectionEnd;\n
                        old = node.value;\n
                        node.value = old.slice(0, start) + string + old.slice(end);\n
                        node.selectionStart = node.selectionEnd = start +\n
                            string.length;\n
                        node.focus();\n
                    } else {\n
                        range = node.createTextRange();\n
                        range.expand(\'textedit\');\n
                        if (range.inRange(the_range)) {\n
                            the_range.select();\n
                            the_range.text = string;\n
                            the_range.select();\n
                        }\n
                    }\n
                }\n
                return this;\n
            },\n
            style: function (name, value) {\n
                reject_global(this);\n
                if (reject_name(name)) {\n
                    error("ADsafe style violation.");\n
                }\n
                if (value === undefined || /url/i.test(string_check(value))) {\n
                    error();\n
                }\n
                var b = this.___nodes___,\n
                    i,\n
                    node,\n
                    v;\n
                if (value instanceof Array) {\n
                    if (value.length !== b.length) {\n
                        error(\'ADsafe: Array length: \' +\n
                            b.length + \'-\' + value.length);\n
                    }\n
                    for (i = 0; i < b.length; i += 1) {\n
                        node = b[i];\n
                        v = string_check(value[i]);\n
                        if (/url/i.test(v)) {\n
                            error();\n
                        }\n
                        if (node.tagName) {\n
                            if (name !== \'float\') {\n
                                node.style[name] = v;\n
                            } else {\n
                                node.style.cssFloat = node.style.styleFloat = v;\n
                            }\n
                        }\n
                    }\n
                } else {\n
                    v = string_check(value);\n
                    if (/url/i.test(v)) {\n
                        error();\n
                    }\n
                    for (i = 0; i < b.length; i += 1) {\n
                        node = b[i];\n
                        if (node.tagName) {\n
                            if (name !== \'float\') {\n
                                node.style[name] = v;\n
                            } else {\n
                                node.style.cssFloat = node.style.styleFloat = v;\n
                            }\n
                        }\n
                    }\n
                }\n
                return this;\n
            },\n
            tag: function (tag, type, name) {\n
                reject_global(this);\n
                var node;\n
                if (typeof tag !== \'string\') {\n
                    error();\n
                }\n
                if (makeableTagName[tag] !== true) {\n
                    error(\'ADsafe: Bad tag: \' + tag);\n
                }\n
                node = document.createElement(tag);\n
                if (name) {\n
                    node.autocomplete = \'off\';\n
                    node.name = string_check(name);\n
                }\n
                if (type) {\n
                    node.type = string_check(type);\n
                }\n
                return new Bunch([node]);\n
            },\n
            text: function (text) {\n
                reject_global(this);\n
                var a, i;\n
                if (text instanceof Array) {\n
                    a = [];\n
                    for (i = 0; i < text.length; i += 1) {\n
                        a[i] = document.createTextNode(string_check(text[i]));\n
                    }\n
                    return new Bunch(a);\n
                }\n
                return new Bunch([document.createTextNode(string_check(text))]);\n
            },\n
            title: function (value) {\n
                reject_global(this);\n
                var b = this.___nodes___, i, node;\n
                if (value instanceof Array) {\n
                    if (value.length !== b.length) {\n
                        error(\'ADsafe: Array length: \' + b.length +\n
                            \'-\' + value.length);\n
                    }\n
                    for (i = 0; i < b.length; i += 1) {\n
                        node = b[i];\n
                        if (node.tagName) {\n
                            node.title = string_check(value[i]);\n
                        }\n
                    }\n
                } else {\n
                    string_check(value);\n
                    for (i = 0; i < b.length; i += 1) {\n
                        node = b[i];\n
                        if (node.tagName) {\n
                            node.title = value;\n
                        }\n
                    }\n
                }\n
                return this;\n
            },\n
            value: function (value) {\n
                reject_global(this);\n
                if (value === undefined) {\n
                    error();\n
                }\n
                var b = this.___nodes___, i, node;\n
                if (value instanceof Array && b.length === value.length) {\n
                    for (i = 0; i < b.length; i += 1) {\n
                        node = b[i];\n
                        if (node.tagName) {\n
                            if (node.type !== \'password\') {\n
                                if (typeof node.value === \'string\') {\n
                                    node.value = value[i];\n
                                } else {\n
                                    while (node.firstChild) {\n
                                        purge_event_handlers(node);\n
                                        node.removeChild(node.firstChild);\n
                                    }\n
                                    node.appendChild(document.createTextNode(\n
                                        String(value[i])\n
                                    ));\n
                                }\n
                            }\n
                        } else if (node.nodeName === \'#text\') {\n
                            node.nodeValue = String(value[i]);\n
                        }\n
                    }\n
                } else {\n
                    value = String(value);\n
                    for (i = 0; i < b.length; i += 1) {\n
                        node = b[i];\n
                        if (node.tagName) {\n
                            if (typeof node.value === \'string\') {\n
                                node.value = value;\n
                            } else {\n
                                while (node.firstChild) {\n
                                    purge_event_handlers(node);\n
                                    node.removeChild(node.firstChild);\n
                                }\n
                                node.appendChild(document.createTextNode(value));\n
                            }\n
                        } else if (node.nodeName === \'#text\') {\n
                            node.nodeValue = value;\n
                        }\n
                    }\n
                }\n
                return this;\n
            }\n
        };\n
\n
// Return an ADsafe dom object.\n
\n
        dom = {\n
            append: function (bunch) {\n
                var b = bunch.___nodes___, i, n;\n
                for (i = 0; i < b.length; i += 1) {\n
                    n = b[i];\n
                    if (typeof n === \'string\' || typeof n === \'number\') {\n
                        n = document.createTextNode(String(n));\n
                    }\n
                    root.appendChild(n);\n
                }\n
                return dom;\n
            },\n
            combine: function (array) {\n
                if (!array || !array.length) {\n
                    error(\'ADsafe: Bad combination.\');\n
                }\n
                var b = array[0].___nodes___, i;\n
                for (i = 0; i < array.length; i += 1) {\n
                    b = b.concat(array[i].___nodes___);\n
                }\n
                return new Bunch(b);\n
            },\n
            count: function () {\n
                return 1;\n
            },\n
            ephemeral: function (bunch) {\n
                if (ephemeral) {\n
                    ephemeral.remove();\n
                }\n
                ephemeral = bunch;\n
                return dom;\n
            },\n
            fragment: function () {\n
                return new Bunch([document.createDocumentFragment()]);\n
            },\n
            prepend: function (bunch) {\n
                var b = bunch.___nodes___, i;\n
                for (i = 0; i < b.length; i += 1) {\n
                    root.insertBefore(b[i], root.firstChild);\n
                }\n
                return dom;\n
            },\n
            q: function (text) {\n
                star = false;\n
                var query = parse_query(text, id);\n
                if (typeof hunter[query[0].op] !== \'function\') {\n
                    error(\'ADsafe: Bad query: \' + query[0]);\n
                }\n
                return new Bunch(quest(query, [root]));\n
            },\n
            remove: function () {\n
                purge_event_handlers(root);\n
                root.parent.removeElement(root);\n
                root = null;\n
            },\n
            row: function (values) {\n
                var tr = document.createElement(\'tr\'),\n
                    td,\n
                    i;\n
                for (i = 0; i < values.length; i += 1) {\n
                    td = document.createElement(\'td\');\n
                    td.appendChild(document.createTextNode(String(values[i])));\n
                    tr.appendChild(td);\n
                }\n
                return new Bunch([tr]);\n
            },\n
            tag: function (tag, type, name) {\n
                var node;\n
                if (typeof tag !== \'string\') {\n
                    error();\n
                }\n
                if (makeableTagName[tag] !== true) {\n
                    error(\'ADsafe: Bad tag: \' + tag);\n
                }\n
                node = document.createElement(tag);\n
                if (name) {\n
                    node.autocomplete = \'off\';\n
                    node.name = name;\n
                }\n
                if (type) {\n
                    node.type = type;\n
                }\n
                return new Bunch([node]);\n
            },\n
            text: function (text) {\n
                var a, i;\n
                if (text instanceof Array) {\n
                    a = [];\n
                    for (i = 0; i < text.length; i += 1) {\n
                        a[i] = document.createTextNode(string_check(text[i]));\n
                    }\n
                    return new Bunch(a);\n
                }\n
                return new Bunch([document.createTextNode(string_check(text))]);\n
            }\n
        };\n
\n
        if (typeof root.addEventListener === \'function\') {\n
            root.addEventListener(\'focus\', dom_event, true);\n
            root.addEventListener(\'blur\', dom_event, true);\n
            root.addEventListener(\'mouseover\', dom_event, true);\n
            root.addEventListener(\'mouseout\', dom_event, true);\n
            root.addEventListener(\'mouseup\', dom_event, true);\n
            root.addEventListener(\'mousedown\', dom_event, true);\n
            root.addEventListener(\'mousemove\', dom_event, true);\n
            root.addEventListener(\'click\', dom_event, true);\n
            root.addEventListener(\'dblclick\', dom_event, true);\n
            root.addEventListener(\'keypress\', dom_event, true);\n
        } else {\n
            root.onfocusin       = root.onfocusout  = root.onmouseout  =\n
                root.onmousedown = root.onmousemove = root.onmouseup   =\n
                root.onmouseover = root.onclick     = root.ondblclick  =\n
                root.onkeypress  = dom_event;\n
        }\n
        return [dom, Bunch.prototype];\n
    }\n
\n
\n
    function F() {}\n
\n
\n
//  Return the ADSAFE object.\n
\n
    return {\n
\n
        create: function (o) {\n
            reject_global(o);\n
            if (Object.hasOwnProperty(\'create\')) {\n
                return Object.create(o);\n
            }\n
            F.prototype = typeof o === \'object\' && o ? o : Object.prototype;\n
            return new F();\n
        },\n
\n
//  ADSAFE.get retrieves a value from an object.\n
\n
        get: function (object, name) {\n
            reject_global(object);\n
            if (arguments.length === 2 && !reject_property(object, name)) {\n
                return object[name];\n
            }\n
            error();\n
        },\n
\n
//  ADSAFE.go allows a guest widget to get access to a wrapped dom node and\n
//  approved ADsafe libraries. It is passed an id and a function. The function\n
//  will be passed the wrapped dom node and an object containing the libraries.\n
\n
        go: function (id, f) {\n
            var dom, fun, root, i, scripts;\n
\n
//  If ADSAFE.id was called, the id better match.\n
\n
            if (adsafe_id && adsafe_id !== id) {\n
                error();\n
            }\n
\n
//  Get the dom node for the widget\'s div container.\n
\n
            root = document.getElementById(id);\n
            if (root.tagName !== \'DIV\') {\n
                error();\n
            }\n
            adsafe_id = null;\n
\n
//  Delete the scripts held in the div. They have all run, so we don\'t need\n
//  them any more. If the div had no scripts, then something is wrong.\n
//  This provides some protection against mishaps due to weakness in the\n
//  document.getElementById function.\n
\n
            scripts = root.getElementsByTagName(\'script\');\n
            i = scripts.length - 1;\n
            if (i < 0) {\n
                error();\n
            }\n
            do {\n
                root.removeChild(scripts[i]);\n
                i -= 1;\n
            } while (i >= 0);\n
            root = make_root(root, id);\n
            dom = root[0];\n
\n
\n
// If the page has registered interceptors, call then.\n
\n
            for (i = 0; i < interceptors.length; i += 1) {\n
                fun = interceptors[i];\n
                if (typeof fun === \'function\') {\n
                    try {\n
                        fun(id, dom, adsafe_lib, root[1]);\n
                    } catch (e1) {\n
                        ADSAFE.log(e1);\n
                    }\n
                }\n
            }\n
\n
//  Call the supplied function.\n
\n
            try {\n
                f(dom, adsafe_lib);\n
            } catch (e2) {\n
                ADSAFE.log(e2);\n
            }\n
            root = null;\n
            adsafe_lib = null;\n
        },\n
\n
//  ADSAFE.has returns true if the object contains an own property with the\n
//  given name.\n
\n
        has: function (object, name) {\n
            return owns(object, name);\n
        },\n
\n
//  ADSAFE.id allows a guest widget to indicate that it wants to load\n
//  ADsafe approved libraries.\n
\n
        id: function (id) {\n
\n
//  Calls to ADSAFE.id must be balanced with calls to ADSAFE.go.\n
//  Only one id can be active at a time.\n
\n
            if (adsafe_id) {\n
                error();\n
            }\n
            adsafe_id = id;\n
            adsafe_lib = {};\n
        },\n
\n
//  ADSAFE.isArray returns true if the operand is an array.\n
\n
        isArray: Array.isArray || function (value) {\n
            return Object.prototype.toString.apply(value) === \'[object Array]\';\n
        },\n
\n
\n
//  ADSAFE.later calls a function at a later time.\n
\n
        later: function (func, timeout) {\n
            if (typeof func === \'function\') {\n
                setTimeout(func, timeout || 0);\n
            } else {\n
                error();\n
            }\n
        },\n
\n
\n
//  ADSAFE.lib allows an approved ADsafe library to make itself available\n
//  to a widget. The library provides a name and a function. The result of\n
//  calling that function will be made available to the widget via the name.\n
\n
        lib: function (name, f) {\n
            if (!adsafe_id || reject_name(name)) {\n
                error("ADsafe lib violation.");\n
            }\n
            adsafe_lib[name] = f(adsafe_lib);\n
        },\n
\n
\n
//  ADSAFE.log is a debugging aid that spams text to the browser\'s log.\n
//  Overwrite this function to send log matter somewhere else.\n
\n
        log: function log(s) {\n
            if (window.console) {\n
                console.log(s);        /* Firebug */\n
            } else if (typeof Debug === \'object\') {\n
                Debug.writeln(s);      /* IE */\n
            } else if (typeof opera === \'opera\') {\n
                opera.postError(s);    /* Opera */\n
            }\n
        },\n
\n
\n
//  ADSAFE.remove deletes a value from an object.\n
\n
        remove: function (object, name) {\n
            if (arguments.length === 2 && !reject_property(object, name)) {\n
                delete object[name];\n
                return;\n
            }\n
            error();\n
        },\n
\n
\n
//  ADSAFE.set stores a value in an object.\n
\n
        set: function (object, name, value) {\n
            reject_global(object);\n
            if (arguments.length === 3 && !reject_property(object, name)) {\n
                object[name] = value;\n
                return;\n
            }\n
            error();\n
        },\n
\n
//  ADSAFE._intercept allows the page to register a function that will\n
//  see the widget\'s capabilities.\n
\n
        _intercept: function (f) {\n
            interceptors.push(f);\n
        }\n
\n
    };\n
}());\n


]]></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
